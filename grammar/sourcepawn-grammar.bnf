{
  parserClass="tf.ngs.sp.lang.SourcePawnParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="SourcePawn"
  psiImplClassSuffix="Impl"
  psiPackage="tf.ngs.sp.lang.psi"
  psiImplPackage="tf.ngs.sp.lang.psi.impl"

  elementTypeHolderClass="tf.ngs.sp.lang.psi.SourcePawnTypes"
  elementTypeClass="tf.ngs.sp.lang.SourcePawnElementType"
  tokenTypeClass="tf.ngs.sp.lang.SourcePawnTokenType"
  generateFirstCheck=50

  tokens = [
    EQ="="
    EXCL="!"
    TILDE="~"
    QUEST="?"
    COLON=":"
    PLUS="+"
    MINUS="-"
    ASTERISK="*"
    DIV="/"
    OR="|"
    XOR="^"
    PERC="%"
    LPAREN="("
    RPAREN=")"
    LBRACE="{"
    RBRACE="}"
    LBRACKET="["
    RBRACKET="]"
    SEMICOLON=";"
    COMMA=","
    ELLIPSIS="..."
    DOT="."
    EQEQ="=="
    NE="!="
    OROR="||"
    PLUSPLUS="++"
    MINUSMINUS="--"
    LT="<"
    LE="<="
    LTLT="<<"
    GT=">"
    AND="&"
    ANDAND="&&"
    PLUSEQ="+="
    MINUSEQ="-="
    ASTERISKEQ="*="
    DIVEQ="/="
    ANDEQ="&="
    OREQ="|="
    XOREQ="^="
    PERCEQ="%="
    LTLTEQ="<<="
    GTGTEQ=">>="

    ASSERT_KEYWORD="assert"
    BREAK_KEYWORD="break"
    CASE_KEYWORD="case"
    CONTINUE_KEYWORD="continue"
    DEFAULT_KEYWORD="default"
    DO_KEYWORD="do"
    ELSE_KEYWORD="else"
    EXIT_KEYWORD="exit"
    FOR_KEYWORD="for"
    GOTO_KEYWORD="goto"
    IF_KEYWORD="if"
    RETURN_KEYWORD="return"
    SLEEP_KEYWORD="sleep"
    STATE_KEYWORD="state"
    SWITCH_KEYWORD="switch"
    WHILE_KEYWORD="while"

    DEFINED_KEYWORD="defined"
    SIZEOF_KEYWORD="sizeof"
    STATE_KEYWORD="state"
    TAGOF_KEYWORD="tagof"

    CONST_KEYWORD="const"
    FORWARD_KEYWORD="forward"
    NATIVE_KEYWORD="native"
    NEW_KEYWORD="new"
    OPERATOR_KEYWORD="operator"
    PUBLIC_KEYWORD="public"
    STATIC_KEYWORD="static"
    STOCK_KEYWORD="stock"

    CHAR_KEYWORD="char"
    INT_KEYWORD="int"
    FLOAT_KEYWORD="float"
    BOOL_KEYWORD="bool"
    VOID_KEYWORD="void"
    ANY_KEYWORD="any"

    DECL_KEYWORD="decl"
    NEW_KEYWORD="new"
    PUBLIC_KEYWORD="public"
    FUNCTAG_KEYWORD="functag"
    METHODMAP_KEYWORD="methodmap"
    TYPEDEF_KEYWORD="typedef"

    // SourcePawn-specific keywords
    ENUM_KEYWORD="enum"
    STRUCT_KEYWORD="struct"

    SPACE="regexp:[ \n\r\t\f]"

    line_comment="regexp://[^\r\n]*"
    block_comment="regexp:/\*([^*]|(\*+[^*/]))*\*+/"
    preprocessor_comment="regexp:#(assert|define|else|elseif|endif|endinput|error|file|if|include|line|pragma|section|tryinclude|undef)[^\r\n]*"

    integer_literal="regexp:[-+]?\d[_\d]*"
    float_literal="regexp:[-+]?\d[_\d]*\.\d[_\d]*(e[-+]?\d+)?"
    hex_literal="regexp:[-+]?0x[a-fA-F0-9_]+"
    binary_literal="regexp:[-+]?0b[01_]+"

    string_literal="regexp:\"(\\.|[^\"])*\""
    character_literal="regexp:'(\\.|[^\"])'"

    // @ and _ are not themselves valid identifiers.
    SYMBOL="regexp:([@_a-zA-Z][@_a-zA-Z0-9]+|[a-zA-Z][@_a-zA-Z0-9]*)"


    // Below is from an attempt to use dvander's grammar as a base
    // See https://wiki.alliedmods.net/SourcePawn_Transitional_Syntax#Grammar
  ]
}

root ::= root_item*
private root_item ::= comment
                      | function
                      | global_assn
                      | methodmap
                      | enum-struct
                      | typedef

global_assn ::= global EQ literal SEMICOLON
                | global EQ struct_block SEMICOLON

struct_block ::= LBRACE struct_decls* RBRACE

struct_decls ::= SYMBOL EQ literal COMMA?
            | SYMBOL EQ SYMBOL COMMA?

comment ::= BLOCK_COMMENT | LINE_COMMENT

function ::= (normalFunctionDeclaration | funcenumDeclaration | functagDeclaration | bareFunctionDeclaration) SEMICOLON?

private normalFunctionDeclaration ::= global LPAREN functionParameterList? RPAREN block
private bareFunctionDeclaration ::= global LPAREN functionParameterList? RPAREN SEMICOLON

private functagDeclaration ::=  FUNCTAG_KEYWORD (OTHER_PUBLIC SYMBOL | SYMBOL SYMBOL? PUBLIC_KEYWORD) BRACKET_PAREN_L functionParameterList? BRACKET_PAREN_R

functionParameterList ::= <<comma_list argdecl>>

block ::= blockStatements?

blockStatements ::= blockStatement*

blockStatement ::= vardecl | statement

statement ::= statementWithoutSubstatement | ifThen | <if then else statement> | <while statement> | <for statement>

statementWithoutSubstatement ::= block | <expression statement> | <switch statement> | <do statement> | <break statement> | <continue statement> | <return statement> | <synchronized statement> | <throws statements> | <try statement> | empty

ifThen ::= IF_KEYWORD LPAREN expr RPAREN statement

ifThenElse ::= IF_KEYWORD LPAREN expr RPAREN statement ELSE_KEYWORD statement

empty ::=

funcenumDeclaration ::= FUNCENUM_KEYWORD SYMBOL LBRACE funcenumBlock RBRACE
funcenumBlock ::= <<optional_comma_list funcenumBlockDeclaration>>
funcenumBlockDeclaration ::= SYMBOL? PUBLIC_KEYWORD LPAREN functionParameterList? RPAREN

meta comma_list ::= <<param>> (SYNTAX_COMMA <<param>>)*
meta optional_comma_list ::= <<param>> (SYNTAX_COMMA <<param>>)* SYNTAX_COMMA?

return_type ::= return_new
return_new ::= type_expr new_dims?

argdecl ::= arg_new
arg_new ::= CONST_KEYWORD? type_expr '&'? SYMBOL old_dims? ('=' arg_init)?
arg_init ::= literal | SYMBOL

vardecl ::= var_new
var_new ::= var_new_prefix type_expr SYMBOL old_dims?
var_new_prefix ::= STATIC_KEYWORD | CONST_KEYWORD

global ::= storage_class* type_expr SYMBOL new_dims?

storage_class ::= PUBLIC_KEYWORD | STATIC_KEYWORD | CONST_KEYWORD | STOCK_KEYWORD

type_expr ::= (builtin_type | SYMBOL) new_dims?
builtin_type ::= VOID_KEYWORD | INT_KEYWORD | FLOAT_KEYWORD | CHAR_KEYWORD | BOOL_KEYWORD | ANY_KEYWORD

new_dims ::= ('[' ']')*
old_dims ::= ('[' expr? ']')+

literal ::= number | string_literal | character_literal
number ::= integer_literal | hex_literal | float_literal

visibility ::= PUBLIC_KEYWORD
method-args ::= arg_new* ELLIPSIS?

methodmap ::= METHODMAP_KEYWORD SYMBOL? LBRACE methodmap-item* RBRACE SEMICOLON?
methodmap-item ::=
           visibility "~"? SYMBOL LPAREN RPAREN "=" SYMBOL term
        | visibility "native" type_expr "~"? SYMBOL methodmap_symbol LPAREN method-args RPAREN
        | visibility type_expr SYMBOL LPAREN method-args RPAREN func-body
        | "property" type_expr SYMBOL { property-decl }
property-func ::= "get" | "set"
property-decl ::= visibility property-impl
property-impl ::=
           "native" property-func LPAREN RPAREN
         | property-func LPAREN RPAREN func-body
         | property-func LPAREN RPAREN "=" SYMBOL

enum-struct ::= ENUM_KEYWORD STRUCT_KEYWORD SYMBOL LBRACE SPACE? enum-struct-entry enum-struct-entry* RBRACE SEMICOLON?
enum-struct-entry ::= enum-struct-field
                    | enum-struct-method
enum-struct-field ::= type_expr SYMBOL old_dims?
enum-struct-method ::= type_expr SYMBOL LPAREN method-args RPAREN functionBlock SEMICOLON?

typedef ::= TYPEDEF_KEYWORD SYMBOL EQ full-type-expr
full-type-expr ::= LPAREN type_expr RPAREN
                 | type_expr
//typedef-args ::= ELLIPSIS
//               | typedef-arg (", " ELLIPSIS)?