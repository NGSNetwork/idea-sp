{
  generate=[java="8" names="long" visitor-value="R"]
  parserClass="tf.ngs.sp.lang.SourcePawnParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="SourcePawn"
  psiImplClassSuffix="Impl"
  psiPackage="tf.ngs.sp.lang.psi"
  psiImplPackage="tf.ngs.sp.lang.psi.impl"

  elementTypeHolderClass="tf.ngs.sp.lang.psi.SourcePawnTypes"
  elementTypeClass="tf.ngs.sp.lang.SourcePawnElementType"
  tokenTypeClass="tf.ngs.sp.lang.SourcePawnTokenType"
  generateFirstCheck=50

  consumeTokenMethod(".*_expr|expr")="consumeTokenFast"

  tokens = [
    space='regexp:\s+'
    EQ="="
    EXCL="!"
    TILDE="~"
    QUEST="?"
    COLON=":"
    PLUS="+"
    MINUS="-"
    ASTERISK="*"
    DIV="/"
    OR="|"
    XOR="^"
    PERC="%"
    LPAREN="("
    RPAREN=")"
    LBRACE="{"
    RBRACE="}"
    LBRACKET="["
    RBRACKET="]"
    SEMICOLON=";"
    COMMA=","
    ELLIPSIS="..."
    DOT="."
    EQEQ="=="
    NE="!="
    OROR="||"
    PLUSPLUS="++"
    MINUSMINUS="--"
    LT="<"
    LE="<="
    LTLT="<<"
    GT=">"
    GE=">="
    GTGT=">>"
    AND="&"
    ANDAND="&&"
    PLUSEQ="+="
    MINUSEQ="-="
    ASTERISKEQ="*="
    DIVEQ="/="
    ANDEQ="&="
    OREQ="|="
    XOREQ="^="
    PERCEQ="%="
    LTLTEQ="<<="
    GTGTEQ=">>="

    ASSERT_KEYWORD="assert"
    BREAK_KEYWORD="break"
    CASE_KEYWORD="case"
    CONTINUE_KEYWORD="continue"
    DEFAULT_KEYWORD="default"
    DO_KEYWORD="do"
    ELSE_KEYWORD="else"
    EXIT_KEYWORD="exit"
    FOR_KEYWORD="for"
    GOTO_KEYWORD="goto"
    IF_KEYWORD="if"
    RETURN_KEYWORD="return"
    SLEEP_KEYWORD="sleep"
    STATE_KEYWORD="state"
    SWITCH_KEYWORD="switch"
    WHILE_KEYWORD="while"
    DELETE_KEYWORD="delete"

    DEFINED_KEYWORD="defined"
    SIZEOF_KEYWORD="sizeof"
    STATE_KEYWORD="state"
    TAGOF_KEYWORD="tagof"

    CONST_KEYWORD="const"
    FORWARD_KEYWORD="forward"
    NATIVE_KEYWORD="native"
    NEW_KEYWORD="new"
    OPERATOR_KEYWORD="operator"
    PUBLIC_KEYWORD="public"
    STATIC_KEYWORD="static"
    STOCK_KEYWORD="stock"
    USING_KEYWORD="using"

    CHAR_KEYWORD="char"
    INT_KEYWORD="int"
    FLOAT_KEYWORD="float"
    BOOL_KEYWORD="bool"
    VOID_KEYWORD="void"
    ANY_KEYWORD="any"

    DECL_KEYWORD="decl"
    NEW_KEYWORD="new"
    PUBLIC_KEYWORD="public"
    FUNCTAG_KEYWORD="functag"
    METHODMAP_KEYWORD="methodmap"
    PROPERTY_KEYWORD="property"
    TYPEDEF_KEYWORD="typedef"
    GET_KEYWORD="get"
    SET_KEYWORD="set"

    // SourcePawn-specific keywords
    ENUM_KEYWORD="enum"
    STRUCT_KEYWORD="struct"

    SPACE="regexp:[ \n\r\t\f]"

    line_comment="regexp://[^\r\n]*"
    block_comment="regexp:/\*([^*]|(\*+[^*/]))*\*+/"
    preprocessor_comment="regexp:#(assert|define|else|elseif|endif|endinput|error|file|if|include|line|pragma|section|tryinclude|undef)[^\r\n]*"

    integer_literal="regexp:[-+]?\d[_\d]*"
    float_literal="regexp:[-+]?\d[_\d]*\.\d[_\d]*(e[-+]?\d+)?"
    hex_literal="regexp:[-+]?0x[a-fA-F0-9_]+"
    binary_literal="regexp:[-+]?0b[01_]+"
    bool_literal="regexp:(true|false)"

    string_literal="regexp:\"(\\.|[^\"])*\""
    character_literal="regexp:'(\\.|[^\"])'"

    // @ and _ are not themselves valid identifiers.
    SYMBOL="regexp:([@_a-zA-Z][@_a-zA-Z0-9]+|[a-zA-Z][@_a-zA-Z0-9]*)"


    // Below is from an attempt to use dvander's grammar as a base
    // See https://wiki.alliedmods.net/SourcePawn_Transitional_Syntax#Grammar
  ]

  extends(".*_expr_r")=expr
}

root ::= root_item*
private root_item ::= comment
                      | function
                      | global_assn
                      | methodmap
                      | enum-struct
                      | enum-block
                      | using
                      | typedef

global_assn ::= global (EQ (literal_expr_r | struct_block | literal_list_block))? SEMICOLON

struct_block ::= LBRACE struct_decls* RBRACE

struct_decls ::= SYMBOL EQ (literal_expr_r | SYMBOL) COMMA?

literal_list_block ::= LBRACE <<comma_list literal_expr_r>> RBRACE

comment ::= BLOCK_COMMENT | LINE_COMMENT

function ::= normalFunctionDeclaration | funcenumDeclaration | functagDeclaration | bareFunctionDeclaration SEMICOLON

private normalFunctionDeclaration ::= global LPAREN functionParameterList? RPAREN block
private bareFunctionDeclaration ::= (FORWARD_KEYWORD)? global LPAREN functionParameterList? RPAREN

private functagDeclaration ::=  FUNCTAG_KEYWORD (OTHER_PUBLIC SYMBOL | SYMBOL SYMBOL? PUBLIC_KEYWORD) BRACKET_PAREN_L functionParameterList? BRACKET_PAREN_R

functionParameterList ::= <<comma_list argdecl>>

block ::= LBRACE blockStatement* RBRACE

blockStatement ::= vardecl | statement

statement ::= statementWithoutSubstatement SEMICOLON | block | returnStatement SEMICOLON | varAssignment SEMICOLON | expr SEMICOLON | switchStatement | doWhileStatement SEMICOLON | ifThenElse | ifThen | whileStatement | forStatement | deleteStatement

statementWithoutSubstatement ::= BREAK_KEYWORD | CONTINUE_KEYWORD

ifThen ::= IF_KEYWORD LPAREN expr RPAREN statement

ifThenElse ::= IF_KEYWORD LPAREN expr RPAREN statement ELSE_KEYWORD statement

whileStatement ::= WHILE_KEYWORD LPAREN expr RPAREN statement

doWhileStatement ::= DO_KEYWORD statement WHILE_KEYWORD LPAREN expr RPAREN

forStatement ::= FOR_KEYWORD LPAREN (expr SEMICOLON | vardecl | SEMICOLON) expr? SEMICOLON expr? RPAREN block

switchStatement ::= SWITCH_KEYWORD LPAREN expr RPAREN LBRACE switchCase+ defaultSwitchCase RBRACE

deleteStatement ::= DELETE_KEYWORD expr SEMICOLON

returnStatement ::= RETURN_KEYWORD expr?

varAssignment ::= SYMBOL varAssignmentOp expr

varAssignmentOp ::= PLUSEQ | MINUSEQ | GTGTEQ | LTLTEQ | ASTERISKEQ | DIVEQ | OREQ | ANDEQ | XOREQ | PERCEQ

switchCase ::= CASE_KEYWORD expr COLON block

defaultSwitchCase ::= DEFAULT_KEYWORD COLON block

expr ::= call_expr_r | ternary_expr_r | parened_expr_r | unop_expr_r | binop_expr_r | index_expr_r | literal_expr_r | term_expr_r

ternary_expr_r ::= expr QUEST expr COLON expr

index_expr_r ::= expr LBRACKET expr RBRACKET

binop_expr_r ::= expr binop expr

call_expr_r ::= SYMBOL (LT type_expr GT)? LPAREN <<comma_list expr>>? RPAREN

binop ::= DOT | EQEQ | NE | LE | LTLT | LT | GE | GTGT | GT | PLUS | MINUS | ASTERISK | DIV | OR | AND | PERC | OROR | ANDAND | EQ

unop_expr_r ::= increm_expr_r | PLUS expr | MINUS expr | EXCL expr | SIZEOF_KEYWORD LPAREN expr RPAREN | NEW_KEYWORD call_expr_r

increm_expr_r ::= pre_increm_expr_r | post_increm_expr_r

pre_increm_expr_r ::= PLUSPLUS SYMBOL | MINUSMINUS SYMBOL

post_increm_expr_r ::= SYMBOL PLUSPLUS | SYMBOL MINUSMINUS

parened_expr_r ::= LPAREN expr RPAREN

term_expr_r ::= SYMBOL

funcenumDeclaration ::= FUNCENUM_KEYWORD SYMBOL LBRACE funcenumBlock RBRACE
funcenumBlock ::= <<optional_comma_list funcenumBlockDeclaration>>
funcenumBlockDeclaration ::= SYMBOL? PUBLIC_KEYWORD LPAREN functionParameterList? RPAREN

meta dot_list ::= <<param>> (DOT <<param>>)*
meta comma_list ::= <<param>> (COMMA <<param>>)*
meta optional_comma_list ::= <<param>> (COMMA <<param>>)* COMMA?

return_type ::= return_new
return_new ::= type_expr old_dims?

argdecl ::= arg_new
arg_new ::= CONST_KEYWORD? type_expr AND? SYMBOL old_dims? (EQ arg_init)?
arg_init ::= literal | SYMBOL

vardecl ::= var_prefix* type_expr? SYMBOL old_dims? (EQ NEW_KEYWORD? expr)? (COMMA SYMBOL old_dims? (EQ NEW_KEYWORD? expr)?)* SEMICOLON
var_prefix ::= STATIC_KEYWORD | CONST_KEYWORD

global ::= global_old | global_new

global_new ::= storage_class* type_expr new_dims? SYMBOL

global_old ::= storage_class* type_expr SYMBOL old_dims*

storage_class ::= PUBLIC_KEYWORD | STATIC_KEYWORD | CONST_KEYWORD | STOCK_KEYWORD | NATIVE_KEYWORD

type_expr ::= (builtin_type | SYMBOL) new_dims?
builtin_type ::= VOID_KEYWORD | INT_KEYWORD | FLOAT_KEYWORD | CHAR_KEYWORD | BOOL_KEYWORD | ANY_KEYWORD

new_dims ::= (LBRACKET RBRACKET)+
old_dims ::= (LBRACKET expr RBRACKET)+

literal_expr_r ::= number | bool_literal | string_literal | character_literal
number ::= integer_literal | hex_literal | float_literal

visibility ::= PUBLIC_KEYWORD
method-args ::= arg_new* ELLIPSIS?

methodmap ::= METHODMAP_KEYWORD SYMBOL (LT SYMBOL)? LBRACE methodmap-item* RBRACE SEMICOLON?
methodmap-item ::=
           visibility? TILDE? SYMBOL LPAREN RPAREN EQ SYMBOL SEMICOLON
        | visibility? NATIVE_KEYWORD type_expr TILDE? SYMBOL LPAREN <<comma_list method-args>> RPAREN SEMICOLON
        | visibility? type_expr SYMBOL LPAREN <<comma_list method-args>> RPAREN block
        | PROPERTY_KEYWORD type_expr SYMBOL { property-decl }
property-func ::= GET_KEYWORD | SET_KEYWORD
property-decl ::= visibility property-impl
property-impl ::=
           NATIVE_KEYWORD property-func LPAREN RPAREN
         | property-func LPAREN RPAREN block
         | property-func LPAREN RPAREN EQ SYMBOL SEMICOLON

enum-struct ::= ENUM_KEYWORD STRUCT_KEYWORD SYMBOL LBRACE enum-struct-entry+ RBRACE SEMICOLON?
enum-struct-entry ::= enum-struct-field
                    | enum-struct-method
enum-struct-field ::= type_expr SYMBOL old_dims? SEMICOLON
enum-struct-method ::= type_expr SYMBOL LPAREN method-args RPAREN block SEMICOLON? // was functionBlock instead of block, unsure why

enum-block ::= ENUM_KEYWORD SYMBOL LBRACE <<comma_list enum-block-entry>> RBRACE SEMICOLON
enum-block-entry ::= SYMBOL (EQ number)?

using ::= USING_KEYWORD <<dot_list SYMBOL>> SEMICOLON

typedef ::= TYPEDEF_KEYWORD SYMBOL EQ full-type-expr
full-type-expr ::= LPAREN type_expr RPAREN
                 | type_expr
//typedef-args ::= ELLIPSIS
//               | typedef-arg (", " ELLIPSIS)?