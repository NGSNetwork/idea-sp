{
  parserClass="net.neogenesisnetwork.sp.lang.SourcePawnParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="SourcePawn"
  psiImplClassSuffix="Impl"
  psiPackage="net.neogenesisnetwork.sp.lang.psi"
  psiImplPackage="net.neogenesisnetwork.sp.lang.psi.impl"

  elementTypeHolderClass="net.neogenesisnetwork.sp.lang.psi.SourcePawnTypes"
  elementTypeClass="net.neogenesisnetwork.sp.lang.SourcePawnElementType"
  tokenTypeClass="net.neogenesisnetwork.sp.lang.SourcePawnTokenType"
  generateFirstCheck=50

  tokens = [
    EQ="="
    EXCL="!"
    TILDE="~"
    QUEST="?"
    COLON=":"
    PLUS="+"
    MINUS="-"
    ASTERISK="*"
    DIV="/"
    OR="|"
    XOR="^"
    PERC="%"
    LPAREN="("
    RPAREN=")"
    LBRACE="{"
    RBRACE="}"
    LBRACKET="["
    RBRACKET="]"
    SEMICOLON=";"
    COMMA=","
    ELLIPSIS="..."
    DOT="."
    EQEQ="=="
    NE="!="
    OROR="||"
    PLUSPLUS="++"
    MINUSMINUS="--"
    LT="<"
    LE="<="
    LTLT="<<"
    GT=">"
    AND="&"
    ANDAND="&&"
    PLUSEQ="+="
    MINUSEQ="-="
    ASTERISKEQ="*="
    DIVEQ="/="
    ANDEQ="&="
    OREQ="|="
    XOREQ="^="
    PERCEQ="%="
    LTLTEQ="<<="
    GTGTEQ=">>="

    ASSERT_KEYWORD="assert"
    BREAK_KEYWORD="break"
    CASE_KEYWORD="case"
    CONTINUE_KEYWORD="continue"
    DEFAULT_KEYWORD="default"
    DO_KEYWORD="do"
    ELSE_KEYWORD="else"
    EXIT_KEYWORD="exit"
    FOR_KEYWORD="for"
    GOTO_KEYWORD="goto"
    IF_KEYWORD="if"
    RETURN_KEYWORD="return"
    SLEEP_KEYWORD="sleep"
    STATE_KEYWORD="state"
    SWITCH_KEYWORD="switch"
    WHILE_KEYWORD="while"

    DEFINED_KEYWORD="defined"
    SIZEOF_KEYWORD="sizeof"
    STATE_KEYWORD="state"
    TAGOF_KEYWORD="tagof"

    CONST_KEYWORD="const"
    FORWARD_KEYWORD="forward"
    NATIVE_KEYWORD="native"
    NEW_KEYWORD="new"
    OPERATOR_KEYWORD="operator"
    PUBLIC_KEYWORD="public"
    STATIC_KEYWORD="static"
    STOCK_KEYWORD="stock"

    CHAR_KEYWORD="char"
    INT_KEYWORD="int"
    FLOAT_KEYWORD="float"
    BOOL_KEYWORD="bool"
    VOID_KEYWORD="void"
    ANY_KEYWORD="any"

    DECL_KEYWORD="decl"
    NEW_KEYWORD="new"
    PUBLIC_KEYWORD="public"
    FUNCTAG_KEYWORD="functag"
    METHODMAP_KEYWORD="methodmap"

    // SourcePawn-specific keywords
    ENUM_KEYWORD="enum"
    STRUCT_KEYWORD="struct"

    SPACE="regexp:[ \n\r\t\f]"

    line_comment="regexp://[^\r\n]*"
    block_comment="regexp:/\*([^*]|(\*+[^*/]))*\*+/"
    preprocessor_comment="regexp:#(assert|define|else|elseif|endif|endinput|error|file|if|include|line|pragma|section|tryinclude|undef)[^\r\n]*"

    integer_literal="regexp:[-+]?\d[_\d]*"
    float_literal="regexp:[-+]?\d[_\d]*\.\d[_\d]*(e[-+]?\d+)?"
    hex_literal="regexp:[-+]?0x[a-fA-F0-9_]+"
    binary_literal="regexp:[-+]?0b[01_]+"

    string_literal="regexp:\"(\\.|[^\"])*\""
    character_literal="regexp:'(\\.|[^\"])'"

    // @ and _ are not themselves valid identifiers.
    identifier="regexp:([@_a-zA-Z][@_a-zA-Z0-9]+|[a-zA-Z][@_a-zA-Z0-9]*)"


    // Below is from an attempt to use dvander's grammar as a base
    // See https://wiki.alliedmods.net/SourcePawn_Transitional_Syntax#Grammar

    // This is dvander's symbol. It doesn't handle all the edge cases Pawn allows (the one below it tries to)
//    symbol="regexp:[A-Za-z_]([A-Za-z0-9_]*)"
  ]
}

root ::= root_item*
private root_item ::= comment
                      | global_assn SEMICOLON
                      | methodmap
                      | function
                      | enum-struct
                      | typedef

global_assn ::= global '=' literal

comment ::= BLOCK_COMMENT | LINE_COMMENT
//private blockComment ::= BLOCK_COMMENT_START (BLOCK_COMMENT_BODY | blockComment)* BLOCK_COMMENT_END

function ::= (funcenumDeclaration | functagDeclaration | bareFunctionDeclaration | normalFunctionDeclaration) SEMICOLON?

private normalFunctionDeclaration ::= [PUBLIC_KEYWORD | STOCK_KEYWORD] builtin_type? identifier LPAREN functionParameterList? RPAREN functionBlock {pin=3}
private bareFunctionDeclaration ::= (FORWARD_KEYWORD | NATIVE_KEYWORD) builtin_type? identifier LPAREN functionParameterList? RPAREN {pin=1}

private functagDeclaration ::=  FUNCTAG_KEYWORD (OTHER_PUBLIC identifier | identifier identifier? PUBLIC_KEYWORD) BRACKET_PAREN_L functionParameterList? BRACKET_PAREN_R {pin=1}

functionParameterList ::= <<comma_list functionParameter>>
functionParameter ::= [CONST_KEYWORD | AND] identifier? (ELLIPSIS | identifier (LBRACKET expression? RBRACKET)* vardecl?)

functionBlock ::= blockStatement | statement

funcenumDeclaration ::= FUNCENUM_KEYWORD identifier LBRACE funcenumBlock RBRACE {pin=1}
funcenumBlock ::= <<optional_comma_list funcenumBlockDeclaration>>
funcenumBlockDeclaration ::= identifier? PUBLIC_KEYWORD LPAREN functionParameterList? RPAREN {pin=2}

meta comma_list ::= <<param>> (SYNTAX_COMMA <<param>>)*
meta optional_comma_list ::= <<param>> (SYNTAX_COMMA <<param>>)* SYNTAX_COMMA?

return_type ::= return_old | return_new
return_new ::= type_expr new_dims?        // Note, dims not yet supported.
return_old ::= old_dims? label?

argdecl ::= arg_old | arg_new
arg_new ::= "const"? type_expr '&'? SYMBOL old_dims? ('=' arg_init)?
arg_old ::= "const"? tags? '&'? SYMBOL old_dims? ('=' arg_init)?
arg_init ::= literal | SYMBOL

vardecl ::= var_old | var_new
var_new ::= var_new_prefix type_expr SYMBOL old_dims?
var_new_prefix ::= "static" | "const"
var_old ::= var_old_prefix tag? SYMBOL old_dims?
var_old_prefix ::= "new" | "decl" | "static" | "const"

global ::= global_old | global_new
global_new ::= storage_class* type_expr SYMBOL old_dims?
global_old ::= storage_class* tag? SYMBOL old_dims?

storage_class ::= PUBLIC_KEYWORD | STATIC_KEYWORD | CONST_KEYWORD | STOCK_KEYWORD

type_expr ::= (builtin_type | SYMBOL) new_dims?
builtin_type ::= VOID_KEYWORD | INT_KEYWORD | FLOAT_KEYWORD | CHAR_KEYWORD | BOOL_KEYWORD | ANY_KEYWORD

tags ::= tag_vector | tag
tag_vector ::= LBRACE SYMBOL (',' SYMBOL)* RBRACE COLON
tag ::= label

new_dims ::= ('[' ']')*
old_dims ::= ('[' expr? ']')+

label ::= SYMBOL ':'

literal ::= number | string_literal | character_literal
number ::= integer_literal | hex_literal | float_literal

visibility ::= PUBLIC_KEYWORD
method-args ::= arg_new* "..."?

methodmap ::= METHODMAP_KEYWORD SYMBOL? { methodmap-item* } term
methodmap-item ::=
           visibility "~"? SYMBOL "(" ")" "=" SYMBOL term
        | visibility "native" type_expr "~"? SYMBOL methodmap_symbol "(" method-args ")" term
        | visibility type_expr SYMBOL "(" method-args ")" func-body term
        | "property" type_expr SYMBOL { property-decl } term
property-func ::= "get" | "set"
property-decl ::= visibility property-impl
property-impl ::=
           "native" property-func "(" ")" term
         | property-func "(" ")" func-body term
         | property-func "(" ")" "=" SYMBOL

enum-struct ::= ENUM_KEYWORD STRUCT_KEYWORD SYMBOL LBRACE SPACE? enum-struct-entry enum-struct-entry* RBRACE SEMICOLON?
enum-struct-entry ::= enum-struct-field
                    | enum-struct-method
enum-struct-field ::= type_expr SYMBOL old_dims? term
enum-struct-method ::= type_expr SYMBOL "(" method-args ")" functionBlock SEMICOLON?

typedef ::= "typedef" SYMBOL "=" full-type-expr term
full-type-expr ::= "(" type_expr ")"
                 | type_expr
//typedef-args ::= "..."
//               | typedef-arg (", " "...")?